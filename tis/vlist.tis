

//|
//| VirtualList - list view bound with the records array. The list is real time bound with the array - view reflects changes in the array.
//|
//| params.container - DOM element, the list containing list items representing records.
//| params.bufferSize - integer, size of sliding window - max number of DOM element used to render records in the view.
//| params.renderItemView - function(recordNo:integer,record: object, itemEl: Element) - function used to render contents of itemEl by record data, optional.
//| params.setupItemView - function(recordNo:integer,record: object, itemEl: Element) - function used to setup contents of itemEl after rendering (add classes etc.), optional.
//| params.getItemData - function(recordNo:integer): object - function gets called on undefined records to fetch record from external source, optional.
//|

//|
//| returns DOM element passed in params.container with the following properties/mthods added:
//| - list.value - array, read/write, recordset (array of objects).
//| - list.currentIndex - integer, read/write, index of current record in records array or -1 if there is no current record
//| - list.current - object, read/write, current record or null if there is no current record.
//| - list.recordView(record|index) - function returns DOM element, used to render given record (or record at index). May return null if the record is out of sliding window.
//|

function VirtualList(params) {
    const list = params.container; assert list;
    const BUFFER_SIZE = params.bufferSize || 100; // sliding buffer size, number of DOM elements in the view
    // const border_spacing = (list.$(div).style#border-spacing).toInteger(#px);
    const border_spacing = 10;
    const offset = 100;
    var   records = null;
    var   template = list.first;
    var   item_height = 10;   // will be adjusted later
    var   buffer_start = 0;   // index of first buffer element in _records
    var   visible_items = 0;  // number of visible items in the view
    var   current_record = undefined;  // current record
    var   cache = [];         // cache of DOM elements - list items

    var   showRecord = params.renderItemView || null;      // showRecord(index,record, itemElement)
    var   setupRecord = params.setupItemView || null;  // setupItemView(index,record, itemElement)
    var   recordData = params.getItemData;
    var   wheelStep = 200;
    var   img_width = 200;
    var   scrollmain;
    var   list_top = list.box(#top, #border, #view);
    var _VL = {
      "isNull" : 1,
      "scrollUp" : 1,
      "scrollDn" : 1,
      "height" : list.box(#height, #border, #self).toInteger(),
      "dataStart" : 0,
      "column" :{}
    };
    function dogc() { gc(); }
    // // // stdout.println(template.outerHtml);
    //multiselection support (not yet)
    //var   selected = params.multiselect ? {} : null; // ATTENTION: if multiselect then each record must have unique .id field
    var   setupSetObserver;
    // // // stdout.println(list.length);
    function columnOnSize(){

    }
    function recordAt(n) {
      // // // stdout.println("recordAt");
      var r = records[n];
      // if(!r && recordData ) {
      //   setupSetObserver(false, true);
      //   r = records[n] = recordData(n);
      //   setupSetObserver(true, true);
      // }
      return r;
    }
    function createRecViewer(rec) {
      var t = cache.pop() || template.clone();
      // assert !t.state.current;
      // t.data = rec;
      return t;
    }

    function appends(el, record){
      if (record["elHeight"] && record["belongColumn"]) {
        scrollmain.$(ul[idx={record.belongColumn}]).append(el);
        return -1;
      }
      var vc = _VL.column;
      var min_vch = -1;
      var vch,min_idx;
      for( var idx=0;idx<vc.length;idx++){
          if ( ((vch = vc[idx.toString()].height) < min_vch) || min_vch == -1 ) {
            min_vch = vch;
            min_idx = idx;
          }
      }
      var min_vc = scrollmain.$(ul[idx={min_idx}]);
      // var last;
      // if (last = min_vc.last) {
      //     last.style#margin-bottom = undefined;
      // }
      min_vc.append(el);
      // vc[min_idx.toString()].height = min_vc.box(#height, #border, #self).toInteger();
      return min_idx.toString();
    }
    function prepends(el, record){
      list.$(ul[idx={record.belongColumn}]).prepend(el);
      return;
      // var (x1,y1,x2,y2) = 0;
      // var first;
      // var max = -9999;
      // var max_column;
      // for( var ul in list.$$(ul) ){
      //   if(first = ul.first){
      //     (x1,y1,x2,y2) = first.box(#rect, #border, #parent);
      //     // // // stdout.println("y1",y1,max);
      //     if (y1 > max) {
      //         max = y1;
      //         max_column = ul;
      //     }
      //   }else{
      //       max_column = ul;
      //       break;
      //   }
      // }
      // // // // stdout.println("max_column",max_column.@#idx);
      // max_column.prepend(el);
    }
    function getListLength(){
      var i = 0;
      for(var ul in scrollmain.$$(ul)){
        i += ul.length;
      }
      return i;
    }

    function detachToCache(vds){
      // if (q1 == 0) return 0;
      var temp = {};
      var tempKey=[];
      var bottom = 0;
      var el, vc;
      for ( var ul in scrollmain.$$(ul) ){
        for( el in ul.$$(li)){
          bottom = el.box(#bottom, #border, #view) - list_top;
          // stdout.println("bottom",bottom);
          if (bottom > 0) break;
          temp[bottom] = el;
          tempKey.push(bottom);
        }
        if (el) {
          vc = _VL.column[ul.@#idx];
          // if (!vc) vc = {};
          vc["referElB"] = el.box(#top, #border, #parent);
          vc["referElI"] = el.@#idx;
          // ul.@#mt = bottom;
          // ul.@#lf = el.@#idx;
          // ul.first.style#margin-top = undefined;
          
        }
      }
      if (tempKey == []) return 0;
      tempKey = tempKey.sort();
      // // stdout.println("tempKey",tempKey);
      var c = tempKey.length;
      // // stdout.println("cache的个数：", c);
      if( vds + BUFFER_SIZE + c > records.length ){
          c = Integer.min( records.length - vds - BUFFER_SIZE , c );
      }
      // // stdout.println("实际cache的个数：", c);
      for( var i=0; i<c; i++ ){
        el = temp[tempKey[i]];
        if(!el) return 0;
        el.style#margin-top = undefined;
        // el.style#margin-bottom = undefined;
        cache.push(el);
        el.detach();
      }
      // list.update();
      return Integer.max(c,0);
    }
    function pumpAfter(i) {
      // 所有浏览过且被移除的节点个数
      var vds = _VL.dataStart;
      // stdout.println("1. vds",vds);
      // // stdout.println("vc1",JSON.stringify(_VL.column,"  "));
      // 需要移除的节点个数
      var q2 = detachToCache(vds);
      // // stdout.println("vc2",JSON.stringify(_VL.column,"  "));
      _VL.dataStart += q2;
      // var list_length = getListLength();
      var list_length = BUFFER_SIZE - q2;
      if (_VL.isNull == 1)
        list_length = _VL.isNull = 0;

      // stdout.println("q2", q2);
      var ni = Integer.min( vds + q2 + list_length, records.length );
      var niend = Integer.min(ni + BUFFER_SIZE - list_length, records.length);
      // stdout.println("ni,niend",ni,niend);

      var vc;

      vc = _VL.column;
      var (elHeight,belongColumn) = 0;
      for( var i = ni; i < niend; ++i )
      {
          var rec = recordAt(i);
          var t = createRecViewer(rec);
          t.@#idx = i;
          belongColumn = appends(t, rec);
          // setupRecordObserver(rec,t);
          showRecord(i,rec,t);
          if ( rec["elHeight"] && rec["belongColumn"] ) {
            continue;
          }
          elHeight = t.box(#height, #border, #self).toInteger();
          // // stdout.println("elHeight",elHeight);
          vc[belongColumn].height += elHeight+border_spacing;
          // vc[belongColumn].height = scrollmain.$(ul[idx={belongColumn}]).box(#height, #border, #self).toInteger() + ;
          // // stdout.println("idx",JSON.stringify(_VL.column,"  "));
          rec["elHeight"] = elHeight;
          rec["belongColumn"] = belongColumn;
          // // // stdout.println("xxx",i,elHeight);
      }
      if (ni < niend) {
        // 获取最短的一列的高度
        vc = _VL.column;
        var min_vch = -1;
        var vch,min_idx;
        for( var idx=0;idx<vc.length;idx++){
            if ( ((vch = vc[idx.toString()].height) < min_vch) || min_vch == -1 ) {
              min_vch = vch;
              min_idx = idx;
            }
        }
        _VL["minColumnH"] = scrollmain.$(ul[idx={min_idx}]).box(#height, #border, #self).toInteger();

        var marginTop = undefined;
        var referEl;
        var eee=0;
        for ( var ul in scrollmain.$$(ul) ){
          vc = _VL.column[ul.@#idx];
          if (ul.first.style#margin-top != undefined) continue;
          referEl = ul.$(li[idx={vc.referElI}]);
          if (!referEl) return;
          eee = referEl.box(#top, #border, #parent);
          // stdout.println("rr",eee,vc.referElB);
          marginTop = Math.abs( vc.referElB - eee );
          ul.first.style#margin-top = px(marginTop);
        }

        list.update();
      }
      return;
    }

    function pumpBefore() {
      return;
      // // stdout.println("pumpBefore");
      var bsn = 9999;  //所有浏览过的节点的个数
      var bottom = 0; //每一列的节点的底部距父节点的距离，判断是否应detach
      var temp = [];
      var marginTop = undefined;  //detach之前节点后，维持当前节点的位置，即是说，每一列是由marginTop撑开的
      var el;
      for ( var ul in list.$$(ul) ){
        // temp = []; // 临时储存应detach的节点，不能在循环中detach，否则无法获取marginTop
        // for ( var el in ul.$$(li) ){
        // }
        // marginTop = ul.first.style#margin-top.toInteger();
        marginTop = ul.first.box(#top, #border, #parent);
        // // // stdout.println("marginTop",marginTop);
        ul.@#mt = marginTop;
        ul.@#lf = ul.first.@#idx;
        ul.first.style#margin-top = undefined;

        while( ul.length ){
          el = ul.last;
          if ( el.box(#top, #border, #parent) > _VL.height ) {
              cache.push(el);
              el.detach();
              continue;
          }
          break;
        }

        // 计算所有浏览过的节点的个数
        if ( ul.first ) {
          // // // stdout.println("ub",ul.first.@#idx.toInteger() , bsn);
          if (ul.first.@#idx.toInteger() < bsn) {
            bsn = ul.first.@#idx.toInteger();
          }
        }else{
          bsn = 0;
        }
      }
      // bsn = Integer.max(bsn-1,0);
      // 取得detach后list剩余节点个数
      var list_length = getListLength();
      var ni = Integer.max(bsn-1,0) ;
      var niend = Integer.max(ni - BUFFER_SIZE + list_length, 0);
      // // // stdout.println("list_length,ni,niend",list_length,ni,niend);
      for(var i=ni; i>=niend; i--){
          var rec = recordAt(i);
          var t = createRecViewer(rec);
          t.@#idx = i;
          prepends(t,rec);
          // setupRecordObserver(rec,t);
          showRecord(i,rec,t);

      }
      list.update();
      var lastFirst;
      var eee=0;
      for ( var ul in list.$$(ul) ){
        lastFirst = ul.$(li[idx={ul.@#lf}]);
        eee = lastFirst.box(#top, #border, #parent);
        marginTop = Math.abs( eee - ul.@#mt.toInteger() );
        // // // stdout.println("eee",ul.@#mt,eee,marginTop);
        // marginTop -= ul.@#mt.toInteger();
        ul.first.style#margin-top = px(marginTop);
        ul.@#mt = marginTop;
      }
      list.update();
      return;
    }

    function wheelUp(){
      list.scrollTo(0, list.scroll(#top) - wheelStep, true, true);
      return;
      /*
      var sy = 0;
      var bottom = 0;
      for ( var ul in scrollmain.$$(ul) ){
        bottom = Integer.max(bottom, ul.first.box(#bottom, #border, #parent) );
        sy = ul.scroll(#top);
        ul.scrollTo(0, sy - wheelStep, true, true);
      }
      if (bottom > 0) {
        // // stdout.println("bottom",bottom);
        pumpBefore(1);
      }
      return;
      */
    }
    function wheelDown(){
      // var scrollmain = list.$(.scrollmain);
      var st = list.scroll(#top);
      // st 为当前滚动条的位置，+wheelStep为预计滚动到的位置，判断滚动结束时与_VL["minColumnH"]的比值
      if ( st + _VL.height + wheelStep > _VL["minColumnH"] - 100) {
        // // stdout.println("rtyxtdrf",_VL["minColumnH"] );
        pumpAfter(1);
      }
      list.scrollTo(0, st + wheelStep, true, true);
      // stdout.println("top, h",st,_VL.height);
      return;
      /*
      var sy = 0;
      var top = 99999;
      for ( var ul in list.$$(ul) ){
        top = Integer.min(top, ul.last.box(#top, #border, #parent) );
        sy = ul.scroll(#top);
        ul.scrollTo(0, sy + wheelStep, true, true);
      }

      if (top-_VL.height < 0) {
        // // stdout.println("top",top-list_height);
        pumpAfter(1);
      }
      return;
      */
    }
    function mousewheel(evt) {
        if (evt.wheelDelta < 0) {
            //内容上移(滚轮向内滚动)
            if( _VL.scrollDn == 1)
                wheelDown();
             // // stdout.println("d");
        } else {
            //内容下移(滚轮向外滚动)
            if( _VL.scrollUp == 1)
                wheelUp();
             // // stdout.println("u");
        }
        return true;
    }

    list.onMouse = function(evt) {
      switch(evt.type) {
        case Event.MOUSE_WHEEL: mousewheel(evt); break;
      }
    }

    setupSetObserver = function(apply, silent = false ){
      if (apply) {
        // // stdout.println("true");

      }
    }

    function initStaggeredGrid(){
      // 初始化瀑布流布局
      var baseW = 270;
      var (container_width, container_height) = list.box(#dimension, #inner);
      var column_count = Math.floor( container_width / baseW.toFloat() + 0.5 ).toInteger();
      var column_width = Math.floor( ( container_width + border_spacing.toFloat() ) / column_count - border_spacing );

      list.style#flow = "vertical";

      list.$append(<div.scrolltop></div>);
      scrollmain = Element.create{div,class:"scrollmain"};
      list.append(scrollmain);
      scrollmain.style#flow = "horizontal";
      var ul;
      for(var i=0;i<column_count;i++){
        scrollmain.insert( ul = Element.create{ ul, idx:i } );
        ul.style.set{ width : px(column_width) };
        _VL.column[i.toString()] = {height : 0};
      }
      list.$append(<div.scrollbottom></div>);
    }

    list[#value] = property(v) {
      get return records;
      set {
        // stdout.println("list.value");
        if ( records !== v ) {
          if (records)
            setupSetObserver(false);
          if(records = v)
            setupSetObserver(true);
        }
        list.clear();
        if( records ){
          initStaggeredGrid();
          pumpAfter.call(list,0);
        }
      }
    }

    list[#offset] = property(v) {
		get return buffer_start;
	}

    if(!showRecord) showRecord = function(i,r,el)
    {
      // // // stdout.println("showRecord");
      // el.value = r; // each item has behavior form so its value is an aggregate
      // el.state.current = current_record === r;
      if(setupRecord) setupRecord(i,r,el);
    };

    // returns "record view" - DOM element that represents nth record.
    //         or null if the record is out of the sliding window
    list.recordView = function( recordOrIndex ) {
      var idx = recordOrIndex;
      if(typeof recordOrIndex != #integer)
        idx = records.indexOf(recordOrIndex);
      if( idx < buffer_start )
        return null; // out of sliding window
      else if( idx >= buffer_start + list.length )
        return null; // out of sliding window
      return list[idx - buffer_start];
    }

    list.clear();
    if( records )
      pumpAfter(0);
    return list;
}

class VList : Behavior
{
  function attached() {
     VirtualList { container: this };
  }
  property animating(v) {
    get return this.state.animating;
  }
}

class VGrid : Behavior
{
  function attached() {
    this.tbody = this.$(tbody);
    VirtualList { container: this.tbody  };
  }

  property value(v) {
    set this.tbody.value = v;
    get return this.tbody.value;
  }

  property animating(v) {
    get return this.tbody.state.animating;
  }


}


